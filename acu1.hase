
// Project:	Array Processor
// Entity	Array Control unit
// File		acu.hase
// Date:	Oct 2005, revised Mar 2014

$class_decls

//entity references

  Clock * myClock;
  memory * myMem;
  pe1 * myPE0;
  pe1 * myPE1;
  pe1 * myPE2;
  pe1 * myPE3;
  pe1 * myPE4;
  pe1 * myPE5;
  pe1 * myPE6;
  pe1 * myPE7;

//structures and variables

  bool d_mem_access, i_mem_access;
  bool new_instrn, new_mpc_value, branch_slot, branch;
  bool condition;
  bool stop, output_src1, output_src2, output_index1, output_index2;
  bool reg_error, div_error, time_out;

  char  Destination[8], Source1[8], Source2[8];
  char new_label[8];
  char src1T, src2T, destT;
  int cycle;  
  int max_cycles;  
  int cond_code;
  int i, literal, sign_bit, sign_ext;
  int mem_address, d_input;
  int alu_fn;
  int dest_regs, source_regs;	// numbers of regs used in instruction
  int dest, src1, src2;	// destination, source1, source2 reg numbers
  t_reg_args dest_args, src1_args, src2_args;	// structures for holding
						// decoded register arguments
  int src1_op, src2_op, dest_op, mask;

  t_prog_reg update;
  t_simd_instrn_set i_input;
  t_i_mem_access imem_request;
  t_d_mem_access dmem_request;

//classes

$class_defs

  char  Destination[8], Source1[8], Source2[8];

  int dest, src1, src2;	// destination, source1, source2 reg numbers
  t_reg_args dest_args, src1_args, src2_args;	// structures for holding
						// decoded register arguments

  t_simd_instrn_set i_input;

$pre

// set up pointers to other entities

myPE0 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._0_")); 
myPE1 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._1_")); 
myPE2 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._2_")); 
myPE3 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._3_")); 
myPE4 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._4_")); 
myPE5 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._5_")); 
myPE6 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._6_")); 
myPE7 = (pe1*)sim.get_entity(sim.get_entity_id("SIMD1._7_")); 

  strcpy(PC.label, "main");
  PC.offset = 0;
  my_state = ACU_IDLE;
  dump_state();
  d_mem_access = false;
  i_mem_access = false;
  new_instrn = false;
  reg_error = false;
  div_error = false;
  time_out = false;

  PE_CONTROL    = 0xFF;		// global PEC

  PEC1          = 0xF;
  PEC0          = 0xF;
  cond_code = 0;


// set max_cycles to 2 ^ log_max_cycles

   max_cycles = 1 << log_max_cycles;

// preset instruction to NOP

  IRA1.reset();
  IRA2.reset();
  IRP.reset();
  i_mem_access = true;
  my_state = ACU_BUSY;
  dump_state();

  myClock = (Clock*) sim.get_entity( sim.get_entity_id( "CLOCK" ) );

$phase0

  cycle = myClock->cycle / 2;

// predicates for use in sim_waiting test

  sim_from_port I_Input(instr_in);	    
  sim_from_port D_Input(data_in);	    

    // DEAL WITH INPUT

  if  (sim_waiting(ev, D_Input) > 0)
       {
	 SIM_CAST_DEL(int, d_input, ev);

	if (IRA1.function == t_simd_instrn_set::LDM)
	 {
	  	strcpy(Destination, IRA1.load_field.dest_reg);
	  	dest_args = Decode_Register(Destination);
		destT  = dest_args.type;
	  	dest  = dest_args.number & 15;
		dest_op = d_input;
		if (destT == 'R')
		 {
		  update.reg_value = dest_op;
	 	  if (dest == 0)
	  	   {update.reg_value = 0;}
	  	  main_reg.Update(dest, update);
		  PC.offset ++;
		  i_mem_access = true;
		 }
		else {reg_error = true;
		stopSimulation(-1);
		}
	 }
	else if (IRA1.function == t_simd_instrn_set::STM)
	 {
		PC.offset ++;
		i_mem_access = true;
	 }
       }
  else if  (sim_waiting(ev, I_Input) > 0)
       {
	SIM_CAST_DEL(t_simd_instrn_set, i_input, ev);
	IRA1 = i_input;
	IRP = i_input;

	stop = false;
	sign_ext = 0;

  if ( (!IRA1.decode_AALU())
    && (!IRA1.decode_AALUI())
    && (!IRA1.decode_AALUM())
    && (!IRA1.decode_ASETPEC())
    && (!Decode_AMISC(IRA1)) )
     {
	my_state = ACU_BUSY;
//	IRP.reset();
	IRA2.reset();

	if (IRA1.function == t_simd_instrn_set::STOP)
	 {
		stop = true;
		my_state = ACU_IDLE;
		stopSimulation(0);
	 }

	if (IRA1.function == t_simd_instrn_set::JUMP)
	 {	// Jump to PC = literal
		literal = IRA1.immediate & 65535;
						// mask off ms 16 bits
		if ((literal & 32768) != 0)
			{sign_ext = -1 ^ 65535;} // generate sign extension
		literal = literal | sign_ext;
	 	strcpy(PC.label, "main");
		PC.offset = literal;
		i_mem_access = true;
	 }

	if (IRA1.function == t_simd_instrn_set::JREG)
	 {	// Jump to PC = value in register
	  	strcpy(Source1, IRA1.src_reg);
	  	src1_args = Decode_Register(Source1);
		src1T  = src1_args.type;
	  	src1  = src1_args.number & 15;
		if (destT == 'R')
		 {
		  src1_op = main_reg[src1].reg_value;
	 	  strcpy(PC.label, "main");
		  PC.offset = src1_op;
		  i_mem_access = true;
		 }
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	 }

	if (IRA1.function == t_simd_instrn_set::BRANCH)
	 {	// Branch if CC = 1
		if (CC == 1)
		 {PC.offset = 0;
		  strcpy(PC.label, IRA1.label);}
		else
		 {PC.offset ++;}
		 i_mem_access = true;
	 }

	if (IRA1.function == t_simd_instrn_set::LDI)
	 {	// Load ACU Register with Immediate
	  	strcpy(Destination, IRA1.loadi_field.dest_reg);
	  	dest_args = Decode_Register(Destination);
		destT  = dest_args.type;
	  	dest  = dest_args.number & 15;
		literal = IRA1.loadi_field.immediate & 65535;
						// mask off ms 16 bits
		if ((literal & 32768) != 0)
			{sign_ext = -1 ^ 65535;} // generate sign extension
		literal = literal | sign_ext;
		dest_op = literal;
		if (destT == 'R')
		 {
		  update.reg_value = dest_op;
	 	  if (dest == 0)
	  	   {update.reg_value = 0;}
	  	  main_reg.Update(dest, update);
		  PC.offset ++;
		  i_mem_access = true;
		 }
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	 }

	if (IRA1.function == t_simd_instrn_set::LPEC)
	 {	// Load PE_CONTROL register with immediate
		PEControl = IRA1.immediate & 0xFFFF;
						// mask off ms 24 bits
		PE_CONTROL = PEControl;
		PC.offset ++;
		i_mem_access = true;
	 }

	if (IRA1.function == t_simd_instrn_set::IPEC)
	 {	// Invert  PE_CONTROL bits
		PEControl = PEControl ^ -1;
		PE_CONTROL = PEControl;
		PC.offset ++;
		i_mem_access = true;
	 }

	if (IRA1.function == t_simd_instrn_set::LDM)
	 {	// Load ACU Register value from memory[address + index]
		d_mem_access = true;
		strcpy(dmem_request.status,"r");
		strcpy(Source1, IRA1.load_field.src_reg);
	  	src1_args = Decode_Register(Source1);
		src1T  = src1_args.type;
	  	src1  = src1_args.number & 15;
		if (src1T == 'R')
		 {
		  src1_op = main_reg[src1].reg_value;
		  mem_address = src1_op + IRA1.load_field.address;
		  dmem_request.address = mem_address;
		  dmem_request.data = 0;
		 }
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	 }

	if (IRA1.function == t_simd_instrn_set::STM)
	 {	// Store ACU Register value to memory[address + index]
		d_mem_access = true;
		strcpy(Source1, IRA1.store_field.src_reg);
	  	src1_args = Decode_Register(Source1);
		src1T  = src1_args.type;
	  	src1  = src1_args.number & 15;
		src1_op = main_reg[src1].reg_value;
		dmem_request.data = src1_op;
		strcpy(Source2, IRA1.store_field.dest_reg);
	  	src2_args = Decode_Register(Source2);
	  	src2  = src2_args.number & 15;
		src2_op = main_reg[src2].reg_value;
		if ((src1T == 'R') && (src2T == 'R'))
		 {
		  mem_address = src2_op + IRA1.store_field.address;
		  dmem_request.address = mem_address;
		 }
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	 }

	if (IRA1.function == t_simd_instrn_set::MOV)
	 {
		strcpy(Source1, IRA1.move_field.src_reg);
		strcpy(Destination, IRA1.move_field.dest_reg);
	  	src1_args = Decode_Register(Source1);
		src1T = src1_args.type;
		if (src1T == 'X')
		 {reg_error = true;
		  stopSimulation(-1);
		 }

	  	src1  = src1_args.number & 15;
		if (src1T == 'R')
		 {
		  src1_op = main_reg[src1].reg_value;
		 }
		else if (src1T == 'P')
		 {
		  src1_op = PE_CONTROL;
		 }
		else if (src1T == 'A')
		 {
		  if (src1_args.number == 0)
		   {src1_op = myPE0->ReadACC();}
		  else if (src1_args.number == 1)
		   {src1_op = myPE1->ReadACC();}
		  else if (src1_args.number == 2)
		   {src1_op = myPE2->ReadACC();}
		  else if (src1_args.number == 3)
		   {src1_op = myPE3->ReadACC();}
		  else if (src1_args.number == 4)
		   {src1_op = myPE4->ReadACC();}
		  else if (src1_args.number == 5)
		   {src1_op = myPE5->ReadACC();}
		  else if (src1_args.number == 6)
		   {src1_op = myPE6->ReadACC();}
		  else if (src1_args.number == 7)
		   {src1_op = myPE7->ReadACC();}
		 }
	  	dest_args = Decode_Register(Destination);
	  	  dest  = dest_args.number & 15;
		  destT = dest_args.type;
		if (destT == 'X')
		 {reg_error = true;
		  stopSimulation(-1);
		 }

		// check for forbidden combinations
		if ( src1T == 'X' || destT == 'X'
		  || ((src1T == 'A') && (destT == 'P'))
		  || ((src1T == 'P') && (destT == 'A')) )
		 {reg_error = true;
		  stopSimulation(-1);
		 }

		 dest_op = src1_op;

		if (destT == 'R')
		 {
		  update.reg_value = dest_op;
	 	   if (dest == 0)
	  	    {update.reg_value = 0;}
	  	  main_reg.Update(dest, update);
		 }

		else if (destT == 'P')
		 {PE_CONTROL = dest_op;}

		else if (destT == 'A')
		 {
		  if (dest_args.number == 0)
		   {myPE0->WriteACC(dest_op);}
		  if (dest_args.number == 1)
		   {myPE1->WriteACC(dest_op);}
		  if (dest_args.number == 2)
		   {myPE2->WriteACC(dest_op);}
		  if (dest_args.number == 3)
		   {myPE3->WriteACC(dest_op);}
		  if (dest_args.number == 4)
		   {myPE4->WriteACC(dest_op);}
		  if (dest_args.number == 5)
		   {myPE5->WriteACC(dest_op);}
		  if (dest_args.number == 6)
		   {myPE6->WriteACC(dest_op);}
		  if (dest_args.number == 7)
		   {myPE7->WriteACC(dest_op);}
		 }
		PC.offset ++;
		i_mem_access = true;
	 }

  if (IRA1.decode_ALU())
   {
  	strcpy(Destination, IRA1.alu_field.dest_reg);
  	strcpy(Source1, IRA1.alu_field.src_reg1);
  	strcpy(Source2, IRA1.alu_field.src_reg2);
  	src1_args = Decode_Register(Source1);
  	src1  = src1_args.number & 15;
	src1T  = src1_args.type;
  	src2_args = Decode_Register(Source2);
  	src2  = src2_args.number & 15;
	src2T  = src2_args.type;
  	dest_args = Decode_Register(Destination);
  	dest  = dest_args.number & 15;
	destT  = dest_args.type;
	if ((src1T == 'R') && (src2T == 'R') &&  (destT == 'R'))
	 {
	  src1_op = main_reg[src1].reg_value;
	  src2_op = main_reg[src2].reg_value;

	 if (IRA1.function == t_simd_instrn_set::ADD)
	  {	// ADD Rx Ry Rz: Rx = Ry + Rz
		dest_op = src1_op + src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SUB)
	  {	// SUB Rx Ry Rz: Rx = Ry - Rz
		dest_op = src1_op - src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::MUL)
	  {	// MUL Rx Ry Rz: Rx = Ry & Rz
		dest_op = src1_op * src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::DIV)
	  {	// DIV Rx Ry Rz: Rx = Ry & Rz
		if (src2_op == 0)
		 {div_error = true;
		  stopSimulation(0);}
		else
		  {dest_op = src1_op / src2_op;}
	  }

	 if (IRA1.function == t_simd_instrn_set::AND)
	  {	// AND Rx Ry Rz: Rx = Ry & Rz
		dest_op = src1_op & src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::OR)
	  {	// OR Rx Ry Rz: Rx = Ry v Rz
		dest_op = src1_op | src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::XOR)
	  {	// XOR Rx Ry Rz: Rx = Ry ^ Rz
		dest_op = src1_op ^ src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SLL)
	  {	// Shift Left Logical Rx Ry Rz: Rx = Ry < Rz
		dest_op = src1_op << src2_op;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SRL)
	  {	// Shift Right Logical Rx Ry Rz: Rx = Ry > Rz
		dest_op = src1_op << src2_op;
		mask = -1 ^ ( ( (pow (2, src2_op)) - 1) << (32 - src2_op));
		dest_op = (src1_op >> src2_op) & mask;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SRA)
	  {	// Shift Right Arithmetic Rx Ry Rz: Rx = Ry > Rz
		sign_bit = src1_op & (1 << 31);
		sign_ext = ( (pow (2, src2_op)) - 1) >> (32 - src2_op);
		dest_op = (src1_op >> src2_op);
			if (sign_bit != 0)
			{dest_op = dest_op | sign_ext;}
	  }

	  update.reg_value = dest_op;
	  if (dest == 0)
	   {update.reg_value = 0;}
	  main_reg.Update(dest, update);
	  PC.offset ++;
	  i_mem_access = true;
	 }	// end of if ((src1T ...))
	else
	 {reg_error = true;
	  stopSimulation(-1);
	 }

   } // end of if ( (IRA1.decode_ALU()) ...)

  if (IRA1.decode_ALUI())
   {
  	strcpy(Destination, IRA1.alui_field.dest_reg);
  	strcpy(Source1, IRA1.alui_field.src_reg1);
	literal = IRA1.alui_field.immediate & 65535;
					// mask off ms 16 bits
	if ((literal & 32768) != 0)
		{sign_ext = -1 ^ 65535;} // generate sign extension
	literal = literal | sign_ext;
	  	src1_args = Decode_Register(Source1);
  	src1  = src1_args.number & 15;
	src1T  = src1_args.type;
  	dest_args = Decode_Register(Destination);
  	dest  = dest_args.number & 15;
	destT  = dest_args.type;
	if ((src1T == 'R') && (destT == 'R'))
	 {
	  src1_op = main_reg[src1].reg_value;

	 if (IRA1.function == t_simd_instrn_set::ADDI)
	  {	// ADDL Rx Ry L: Rx = Ry + Literal
		dest_op = src1_op + literal;
	   }

	 else if (IRA1.function == t_simd_instrn_set::SUBI)
	  {	// SUB Rx Ry L: Rx = Ry - Literal
		  dest_op = src1_op - literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::MULI)
	  {	// MULL Rx Ry L: Rx = Ry * Literal
		  dest_op = src1_op * literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::DIVI)
	  {	// DIVL Rx Ry L: Rx = Ry / Literal
		if (literal == 0)
		 {div_error = true;
		  stopSimulation(0);}
		else
		  {dest_op = src1_op / literal;}
	  }

	 else if (IRA1.function == t_simd_instrn_set::ANDI)
	  {	// AND Rx Ry L: Rx = Ry & Literal
		  dest_op = src1_op & literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::ORI)
	  {	// OR Rx Ry L: Rx = Ry v Literal
		  dest_op = src1_op | literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::XORI)
	  {	// XOR Rx Ry L: Rx = Ry ^ Literal
		  dest_op = src1_op ^ literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SLLI)
	  {	// Shift Left Logical Rx Ry Rz: Rx = Ry > Literal
		  dest_op = src1_op << literal;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SRLI)
	  {	// Shift Right Logical Rx Ry L: Rx = Ry > Literal
		  mask = -1 ^ ( ( (pow (2, literal)) - 1) << (32 - literal));
		  dest_op = (src1_op >> literal) & mask;
	  }

	 else if (IRA1.function == t_simd_instrn_set::SRAI)
	  {	// Shift Right Arithmetic Rx Ry L: Rx = Ry > Literal
		  sign_bit = src1_op & (1 << 31);
		  sign_ext = ( (pow (2, literal)) - 1) >> (32 - literal);
		  dest_op = (src1_op >> literal);
			if (sign_bit != 0)
			{dest_op = dest_op | sign_ext;}
	  }

		  update.reg_value = dest_op;
	 	  if (dest == 0)
	  	   {update.reg_value = 0;}
	  	  main_reg.Update(dest, update);
		  PC.offset ++;
		  i_mem_access = true;
	}	// end of if ((src1T ...))
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }
   }	// end of if ( (IRA1.decode_ALUL()) ... )


  if (IRA1.decode_SETCC() )
   {
  	strcpy(Source1, IRA1.comp_field.src_reg1);
  	strcpy(Source2, IRA1.comp_field.src_reg2);
  	src1_args = Decode_Register(Source1);
  	src1  = src1_args.number & 15;
	src1T  = src1_args.type;
  	src2_args = Decode_Register(Source2);
  	src2  = src2_args.number & 15;
	src2T  = src2_args.type;
	if ((src1T == 'R') && (src2T == 'R'))
	 {
	  src1_op = main_reg[src1].reg_value;
	  src2_op = main_reg[src2].reg_value;
	  CC = 0;	

	 if (IRA1.function == t_simd_instrn_set::SEQ)
	  {	// Set CC = 1 if RS1 = RS2
	 	  if (src1_op == src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SEQ\n");
	  }

	 else if (IRA1.function == t_simd_instrn_set::SNE)
	  {	// Set CC = 1 if RS1 != RS2
	 	  if (src1_op != src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SNE\n");
	  }

	 else if (IRA1.function == t_simd_instrn_set::SGT)
	  {	// Set CC = 1 if RS1 > RS2
	 	  if (src1_op > src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SG\n");
	  }

	 else if (IRA1.function == t_simd_instrn_set::SLT)
	  {	// Set CC = 1 if RS1 < RS2
	 	  if (src1_op < src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SLT\n");
	  }

	 else if (IRA1.function == t_simd_instrn_set::SGE)
	  {	// Set CC = 1 if RS1 >= RS2
	 	  if (src1_op >= src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SGE\n");
	   }

	 else if (IRA1.function == t_simd_instrn_set::SLE)
	  {	// Set CC = 1 if RS1 <= RS2
	 	  if (src1_op <= src2_op)
	  	   {CC = 1;}
//		printf("ACU: executing SLE\n");
	   }

	 	  PC.offset ++;
		  i_mem_access = true;
	}	// end of if (( src1T ...))
		else
		 {reg_error = true;
		  stopSimulation(-1);
		 }

   }	// end of SETCC instructions

 }	// end of if (( (!IRA1.decode_AALU()) ... ))
  else	// Array instructions
    {
	IRA2 = IRA1;
	if (IRA1.decode_ASETPEC())
   	 {
	  PE_CONTROL = 0;
	  //printf("ACU:executing ASETPEC\n");
	 }

	 if (IRA1.function == t_simd_instrn_set::ALDR)
	  {
	   strcpy(Source1, IRA1.loadr_field.src_reg);
   	   src1_args = Decode_Register(Source1);
	   src1  = src1_args.number & 15;
	   src1T  = src1_args.type;
		if (src1T != 'R')
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	   IRA2.function = t_simd_instrn_set::ALDI;
	   IRA2.immediate = main_reg[src1].reg_value;
	   IRP = IRA2;
	  }

	 if (IRA1.decode_AALUM())
	  {
	  // PE operand is from memory[address + index]
	   strcpy(Source1, IRA1.a_alum_field.src_reg);
   	   src1_args = Decode_Register(Source1);
	   src1  = src1_args.number & 15;
	   src1T  = src1_args.type;
		if (src1T != 'R')
		 {reg_error = true;
		  stopSimulation(-1);
		 }
	   IRA2 = IRA1; 
	   IRA2.a_alum_field.address = main_reg[src1].reg_value + IRA1.a_alum_field.address;
	   IRP = IRA2;
//		  printf("ACU: executing AALUM, address = %d\n",immediate );
	  }
	PC.offset ++;
        i_mem_access = true;

    }
	
	dump_state();
 
	} 		// end of code for new instruction pkt

$phase1

// stop simulation if max cycles exceeded

  if (no>=max_cycles) 
	{
	 time_out = true;
	 stopSimulation(0);
	}

  PEControl = PE_CONTROL;	// PE_CONTROL is the global variable
				// PE_Control is the version displayed
	PEC0 = PEControl & 15;
	PEC1 = (PEControl >> 4) & 15;
//	PEC2 = (PEControl >> 8) & 15;
//	PEC3 = (PEControl >> 12) & 15;

	IRP.reset();

	dump_state_i();

  if (i_mem_access) {
	imem_request.address.offset = PC.offset;
	strcpy(imem_request.address.label,PC.label);
	strcpy(imem_request.status,"i");
	send_I_MEM_ACCESS(instr_request, imem_request);
	i_mem_access = false;
	my_state = ACU_IDLE;
	dump_state();
	}

  if (d_mem_access) {
	send_D_MEM_ACCESS(data_request, dmem_request);
	d_mem_access = false;
	}

	// end of  ClockPhase 1

$report

  if (reg_error)
   {printf("Simulation aborted: invalid register type in instruction at PC = %s, %d\n", PC.label, PC.offset);}

  if (time_out)
   {printf("Simulation timed out -> increase ACU max_cycles\n");}

